<head>
    <style>
        body {
            margin: 0;
        }
    </style>

    <script type="importmap">{ "imports": {
      "three": "https://esm.sh/three",
      "three/": "https://esm.sh/three/"
    }}</script>

    <!--  <script type="module"> import * as THREE from 'three'; window.THREE = THREE;</script>-->
    <!--  <script src="../../dist/three-globe.js" defer></script>-->
</head>

<body>
    <div id="globeViz"></div>

    <script type="module">
        import ThreeGlobe from 'https://esm.sh/three-globe?external=three';
        import * as THREE from 'https://esm.sh/three';
        import { TrackballControls } from 'three/examples/jsm/controls/TrackballControls.js?external=three';

        let apiData = [];

        function statusToColorMapper(status) {
            // what are the possible values for status?
            switch (status) {
                case 'operational':
                    return 'green';
                case 'partial_outage':
                    return 'orange';
                case 'under_maintenance':
                    return 'red';
                default:
                    return 'gray';
            }
        }

        async function fetchApiData() {
            const apiUrl = '/api/pops_with_coordinates_and_status';

            /*
            Example of the API response we will get:

             {
                "id": "57ctn3f2qsyj",
                "name": "Amsterdam, Netherlands - (AMS)",
                "status": "operational",
                "updated_at": "2025-03-03T18:19:46.395Z",
                "lat": 52.3086013794,
                "lon": 4.7638897896,
                }
            */

            try {
                const response = await fetch(apiUrl);

                if (!response.ok) {
                    throw new Error('Network response was not ok ' + response.statusText);
                }

                apiData = await response.json();

                // Map the API data to the format expected by ThreeGlobe
                apiData.map(item => {
                    item.lng = item.lon;
                    delete item.lon;
                    item.color = statusToColorMapper(item.status);
                    item.size = 1; // default size, you can adjust this based on your needs
                    return item;
                })

                // Display the data on the page
                const globe = await generateGlobe(apiData);
                await renderGlobe(globe);
            } catch (error) {
                console.error('There was a problem with the fetch operation:', error);
            }
        }

        // Fetch API data on page load
        window.addEventListener('load', fetchApiData);

        async function generateGlobe(data) {

            /*
            // let's download the two images concurrently
            // we could even do this in parallel with the fetchApiData call
            const [globeImage, bumpImage] = await Promise.all([
                fetch('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-dark.jpg').then(res => res.blob()),
                fetch('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-topology.png').then(res => res.blob())
            ]);
            */

            const Globe = new ThreeGlobe()
                .globeImageUrl('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-night.jpg')
                .bumpImageUrl('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-topology.png')
                .labelsData(data) // not clear to me which format is expected, the docs don't say
                .labelText(d => `${d.name}`) // d.name is the name of the city, d.status is the status
                .labelSize(0.15)
                .labelDotRadius(d => 0.25)
                .labelColor(d => d.color); // todo: here we have to do the mapping between the status and the color
            return Globe;
        }

        async function renderGlobe(Globe) {

            // Setup renderer
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            const globeViz = document.getElementById('globeViz');
            if (!globeViz) {
                throw new Error('Element with id "globeViz" not found');
            }
            
            globeViz.appendChild(renderer.domElement);

            // Setup scene
            const scene = new THREE.Scene();
            scene.add(Globe);
            scene.add(new THREE.AmbientLight(0xcccccc, Math.PI));
            scene.add(new THREE.DirectionalLight(0xffffff, 0.6 * Math.PI));

            // Setup camera
            const camera = new THREE.PerspectiveCamera();
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            camera.position.z = 500;

            // Add camera controls
            const tbControls = new TrackballControls(camera, renderer.domElement);
            tbControls.minDistance = 101;
            tbControls.rotateSpeed = 5;
            tbControls.zoomSpeed = 0.8;

            // Kick-off renderer
            (function animate() { // IIFE, this is a self-invoking function
                // Frame cycle
                tbControls.update();
                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            })();
        }
    </script>
</body>